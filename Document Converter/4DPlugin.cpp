/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Document Converter
 #	author : miyako
 #	2017/10/31
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"
#include "libjson.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Document Converter

		case 1 :
			Convert_document(pResult, pParams);
			break;

	}
}

// ------------------------------ Document Converter ------------------------------

#pragma mark JSON

JSONNODE *json_parse_text_param(C_TEXT &t)
{
	uint32_t dataSize = (t.getUTF16Length() * sizeof(wchar_t))+ sizeof(wchar_t);
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /4 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)t.getUTF16StringPtr(),
																						t.getUTF16Length() * sizeof(PA_Unichar),
																						eVTC_UTF_16,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_32);
	std::wstring u32 = std::wstring((wchar_t *)&buf[0], len/sizeof(wchar_t));
	return json_parse((json_const json_char *)u32.c_str());
}

void json_stringify(JSONNODE *json, BOOL pretty)
{
	json_char *json_string = pretty ? json_write_formatted(json) : json_write(json);
	std::wstring wstr = std::wstring(json_string);
	uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
	std::vector<char> buf(dataSize);
	//returns byte size in toString (in this case, need to /2 to get characters)
	uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																						(PA_long32)(wstr.length() * sizeof(wchar_t)),
																						eVTC_UTF_32,
																						(char *)&buf[0],
																						dataSize,
																						eVTC_UTF_16);
	CUTF16String t = CUTF16String((const PA_Unichar *)&buf[0], len/sizeof(PA_Unichar));
	NSLog(@"%S", t.c_str());
	json_free(json_string);
}

void json_set_z(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_NODE)
			{
				JSONNODE *w = json_get(n, L"width");
				JSONNODE *h = json_get(n, L"height");
				
				if((w) && (h))
				{
					if((json_type(w) == JSON_NUMBER) && (json_type(h) == JSON_NUMBER))
					{
						[dict setValue:[NSValue valueWithSize:NSMakeSize(json_as_float(w), json_as_float(h))] forKey:attr];
					}
				}
			}
		}
	}
}

void json_set_c(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_NODE)
			{
				JSONNODE *r = json_get(n, L"red");
				JSONNODE *g = json_get(n, L"green");
				JSONNODE *b = json_get(n, L"blue");
				JSONNODE *a = json_get(n, L"alpha");
				
				if((r) && (g) && (b) && (a))
				{
					if((json_type(r) == JSON_NUMBER) && (json_type(g) == JSON_NUMBER) && (json_type(b) == JSON_NUMBER) && (json_type(a) == JSON_NUMBER))
					{
						[dict setValue:[NSColor colorWithDeviceRed:json_as_float(r) green:json_as_float(g) blue:json_as_float(b) alpha:json_as_float(a)] forKey:attr];
					}
				}
			}
		}
	}
}

void json_set_n(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_NUMBER)
			{
				[dict setValue:[NSNumber numberWithDouble:json_as_float(n)] forKey:attr];
			}
		}
	}
}

void json_set_s(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_STRING)
			{
				json_char *json_string = json_as_string(n);
				std::wstring wstr = std::wstring(json_string);
				uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
				std::vector<char> buf(dataSize);
				//returns byte size in toString (in this case, need to /2 to get characters)
				uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																									(PA_long32)(wstr.length() * sizeof(wchar_t)),
																									eVTC_UTF_32,
																									(char *)&buf[0],
																									dataSize,
																									eVTC_UTF_16);
				NSString *str = [[NSString alloc]initWithCharacters:(const unichar *)&buf[0] length:len/sizeof(PA_Unichar)];
				[dict setValue:str forKey:attr];
				[str release];
				json_free(json_string);
			}
		}
	}
}

void json_set_v(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_ARRAY)
			{
				NSMutableArray *arr = [[NSMutableArray alloc]initWithCapacity:json_size(n)];
				for(json_index_t i = 0; i < json_size(n); ++i)
				{
					JSONNODE *e = json_at(n, i);
					if(json_type(e) == JSON_STRING)
					{
						json_char *json_string = json_as_string(e);
						std::wstring wstr = std::wstring(json_string);
						uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
						std::vector<char> buf(dataSize);
						//returns byte size in toString (in this case, need to /2 to get characters)
						uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																											(PA_long32)(wstr.length() * sizeof(wchar_t)),
																											eVTC_UTF_32,
																											(char *)&buf[0],
																											dataSize,
																											eVTC_UTF_16);
						NSString *str = [[NSString alloc]initWithCharacters:(const unichar *)&buf[0] length:len/sizeof(PA_Unichar)];
						[arr addObject:str];
						[str release];
						json_free(json_string);
					}
				}
				[dict setValue:arr forKey:attr];
				[arr release];
			}
		}
	}
}

void json_set_u(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_STRING)
			{
				json_char *json_string = json_as_string(n);
				std::wstring wstr = std::wstring(json_string);
				uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
				std::vector<char> buf(dataSize);
				//returns byte size in toString (in this case, need to /2 to get characters)
				uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																									(PA_long32)(wstr.length() * sizeof(wchar_t)),
																									eVTC_UTF_32,
																									(char *)&buf[0],
																									dataSize,
																									eVTC_UTF_16);
				NSString *str = [[NSString alloc]initWithCharacters:(const unichar *)&buf[0] length:len/sizeof(PA_Unichar)];
				NSURL *url = [[NSURL alloc]initWithString:str];
				if(url)
				{
					[dict setValue:url forKey:attr];
					[url release];
				}
				[str release];
				json_free(json_string);
			}
		}
	}
}

void json_set_d(JSONNODE *json, json_const json_char *key, NSDictionary *dict, NSString *attr)
{
	if(json)
	{
		JSONNODE *n = json_get(json, key);
		if(n)
		{
			if(json_type(n) == JSON_STRING)
			{
				json_char *json_string = json_as_string(n);
				std::wstring wstr = std::wstring(json_string);
				uint32_t dataSize = (uint32_t)((wstr.length() * sizeof(wchar_t))+ sizeof(PA_Unichar));
				std::vector<char> buf(dataSize);
				//returns byte size in toString (in this case, need to /2 to get characters)
				uint32_t len = PA_ConvertCharsetToCharset((char *)wstr.c_str(),
																									(PA_long32)(wstr.length() * sizeof(wchar_t)),
																									eVTC_UTF_32,
																									(char *)&buf[0],
																									dataSize,
																									eVTC_UTF_16);
				NSString *str = [[NSString alloc]initWithCharacters:(const unichar *)&buf[0] length:len/sizeof(PA_Unichar)];
				
				NSDateFormatter *ISO = [[NSDateFormatter alloc]init];
				NSDateFormatter *GMT = [[NSDateFormatter alloc]init];

				[ISO setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss"];
				[ISO setTimeZone:[NSTimeZone localTimeZone]];
				
				[GMT setDateFormat:@"yyyy-MM-dd'T'HH:mm:ss'Z'"];
				[GMT setTimeZone:[NSTimeZone timeZoneForSecondsFromGMT:0]];
				
				NSDate *date = [GMT dateFromString:str];
				date = date ? date : [ISO dateFromString:str];
				date = date ? date : [NSDate dateWithString:str]; //YYYY-MM-DD HH:MM:SS ±HHMM
	
				if(date)
				{
					[dict setValue:date forKey:attr];
				}
				[str release];
				
				[GMT release];
				[ISO release];
				
				json_free(json_string);
			}
		}
	}
}

#pragma mark parse

void parseData(ConverterContext *context)
{
	NSError *error = nil;
	NSAttributedString *dst = [[NSAttributedString alloc]initWithData:context->src
																														options:context->src_options
																								 documentAttributes:NULL
																															error:&error];
	if(dst)
	{
		if([[context->dst_options valueForKey:NSDocumentTypeDocumentAttribute]isEqualToString:NSPlainTextDocumentType])
		{
			context->dst = [[dst string]dataUsingEncoding:NSUTF8StringEncoding];
						
			//err:517
			/*
			context->dst = [dst dataFromRange:NSMakeRange(0, [dst length])
										 documentAttributes:@{NSDocumentTypeDocumentAttribute:NSPlainTextDocumentType}
																	error:&error];
			 */

		}else
		{
			context->dst = [dst dataFromRange:NSMakeRange(0, [dst length])
										 documentAttributes:context->dst_options
																	error:&error];
		}
		
		[dst release];
	}

}

#pragma mark -

void Convert_document(sLONG_PTR *pResult, PackagePtr pParams)
{
	@autoreleasepool
	{
		int src_fmt = *(int *)(pParams[1]); //Param2
		int dst_fmt = *(int *)(pParams[2]); //Param3
		
		PA_Handle hParam1 = *(PA_Handle *)(pParams[0]);
		if(hParam1)
		{
			NSData *src = [[NSData alloc]initWithBytes:PA_LockHandle(hParam1) length:PA_GetHandleSize(hParam1)];
			if(src)
			{
				ConverterContext context;
				
				NSMutableDictionary *src_options;//read
				NSMutableDictionary *dst_options;//write
				
				/*
				 defaults for src:
				 NSDocumentTypeDocumentAttribute:NSPlainTextDocumentType
				 NSTimeoutDocumentOption:60.0f
				 */
				
				src_options = [[NSMutableDictionary alloc]initWithObjects:@[
																																		NSPlainTextDocumentType,
																																		[NSNumber numberWithFloat:60.0f]
																																		]
																													forKeys:@[
																																		NSDocumentTypeDocumentAttribute,
																																		NSTimeoutDocumentOption
																																		]];
				/*
				 defaults for dst:
				 NSDocumentTypeDocumentAttribute:NSPlainTextDocumentType
				 */
				
				dst_options = [[NSMutableDictionary alloc]initWithObjects:@[
																																		NSPlainTextDocumentType
																																		]
																													forKeys:@[
																																		NSDocumentTypeDocumentAttribute
																																		]];
				switch (dst_fmt)
				{
					case Document_format_HTML:
						[dst_options setObject:NSHTMLTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_RTF:
						[dst_options setObject:NSRTFTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_RTFD:
						[dst_options setObject:NSRTFDTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_DOC:
						[dst_options setObject:NSDocFormatTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_DOCX:
						[dst_options setObject:NSOfficeOpenXMLTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_ODT:
						[dst_options setObject:NSOpenDocumentTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_WORDML:
						[dst_options setObject:NSWordMLTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_WEBARCHIVE:
						[dst_options setObject:NSWebArchiveTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
				}
				
				//custom option for src and dst
				C_TEXT Param4;
				Param4.fromParamAtIndex(pParams, 4);
				JSONNODE *json = json_parse_text_param(Param4);
				//json_stringify(json, NO);
				
				//dst_options
				
				json_set_s(json, L"author", dst_options, NSAuthorDocumentAttribute);
				json_set_s(json, L"copyright", dst_options, NSCopyrightDocumentAttribute);
				json_set_s(json, L"company", dst_options, NSCompanyDocumentAttribute);
				json_set_s(json, L"manager", dst_options, NSManagerDocumentAttribute);
				json_set_s(json, L"editor", dst_options, NSEditorDocumentAttribute);
				json_set_s(json, L"title", dst_options, NSTitleDocumentAttribute);
				json_set_s(json, L"subject", dst_options, NSSubjectDocumentAttribute);
				json_set_s(json, L"category", dst_options, NSCategoryDocumentAttribute);
				json_set_s(json, L"comment", dst_options, NSCommentDocumentAttribute);
				json_set_s(json, L"textEncodingName", dst_options, NSTextEncodingNameDocumentAttribute);
				
				json_set_n(json, L"topMargin", dst_options, NSTopMarginDocumentAttribute);
				json_set_n(json, L"leftMargin", dst_options, NSLeftMarginDocumentAttribute);
				json_set_n(json, L"bottomMargin", dst_options, NSBottomMarginDocumentAttribute);
				json_set_n(json, L"rightMargin", dst_options, NSRightMarginDocumentAttribute);
				json_set_n(json, L"converted", dst_options, NSConvertedDocumentAttribute);
				json_set_n(json, L"readOnly", dst_options, NSReadOnlyDocumentAttribute);
				json_set_n(json, L"viewZoom", dst_options, NSViewZoomDocumentAttribute);
				json_set_n(json, L"viewMode", dst_options, NSViewModeDocumentAttribute);
				json_set_n(json, L"hyphenationFactor", dst_options, NSHyphenationFactorDocumentAttribute);
				json_set_n(json, L"defaultTabInterval", dst_options, NSDefaultTabIntervalDocumentAttribute);
				json_set_n(json, L"prefixSpaces", dst_options, NSPrefixSpacesDocumentAttribute);
				json_set_n(json, L"cocoaVersion", dst_options, NSCocoaVersionDocumentAttribute);
				
				json_set_z(json, L"viewSize", dst_options, NSViewSizeDocumentAttribute);
				json_set_z(json, L"paperSize", dst_options, NSPaperSizeDocumentAttribute);
				
				json_set_d(json, L"creationTime", dst_options, NSCreationTimeDocumentAttribute);
				json_set_d(json, L"modificationDate", dst_options, NSModificationTimeDocumentAttribute);
				
				json_set_c(json, L"backgroundColor", dst_options, NSBackgroundColorDocumentAttribute);
				
				json_set_v(json, L"excludedElements", dst_options, NSExcludedElementsDocumentAttribute);
				json_set_v(json, L"keywords", dst_options, NSKeywordsDocumentAttribute);
				
				//src_options
				json_set_u(json, L"baseURL", src_options, NSBaseURLDocumentOption);
				json_set_n(json, L"timeout", src_options, NSTimeoutDocumentOption);
				json_set_n(json, L"textSizeMultiplier", src_options, NSTextSizeMultiplierDocumentOption);
				
				json_delete(json);
				
				switch (src_fmt)
				{
					case Document_format_HTML:
						[src_options setObject:NSHTMLTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_RTF:
						[src_options setObject:NSRTFTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_RTFD:
						[src_options setObject:NSRTFDTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_DOC:
						[src_options setObject:NSDocFormatTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_DOCX:
						[src_options setObject:NSOfficeOpenXMLTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_ODT:
						[src_options setObject:NSOpenDocumentTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_WORDML:
						[src_options setObject:NSWordMLTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
					case Document_format_WEBARCHIVE:
						[src_options setObject:NSWebArchiveTextDocumentType forKey:NSDocumentTypeDocumentAttribute];
						break;
				}
				
				context.src = src;
				context.dst = nil;
				context.src_options = src_options;
				context.dst_options = dst_options;
				
				NSLog(@"src_options:\n%@\n", src_options);
				NSLog(@"dst_options:\n%@\n", dst_options);
				
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)parseData, (void *)&context);
				
				NSData *dst = context.dst;
				
				if(dst)
				{
					if([dst length])
					{
						PA_Handle *hReturnValue = (PA_Handle *)pResult;
						PA_Handle d = PA_NewHandle((PA_long32)[dst length]);
						PA_MoveBlock((char *)[dst bytes], PA_LockHandle(d), (unsigned int)[dst length]);
						PA_UnlockHandle(d);
						*hReturnValue = d;
					}//dst.length
					
				}//dst (we don't own this object, don't release it)
				
				[src_options release];
				[dst_options release];
				
				[src release];
			}//src
			PA_UnlockHandle(hParam1);
		}//hParam1
		
	}//autoreleasepool
}
